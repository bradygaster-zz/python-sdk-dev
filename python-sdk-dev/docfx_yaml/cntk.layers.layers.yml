#YamlMime:PythonReference
api_name: []
items:
- _type: module
  children:
  - cntk.layers.layers.Activation
  - cntk.layers.layers.AveragePooling
  - cntk.layers.layers.BatchNormalization
  - cntk.layers.layers.Convolution
  - cntk.layers.layers.Convolution1D
  - cntk.layers.layers.Convolution2D
  - cntk.layers.layers.Convolution3D
  - cntk.layers.layers.ConvolutionTranspose
  - cntk.layers.layers.ConvolutionTranspose1D
  - cntk.layers.layers.ConvolutionTranspose2D
  - cntk.layers.layers.ConvolutionTranspose3D
  - cntk.layers.layers.Dense
  - cntk.layers.layers.Dropout
  - cntk.layers.layers.Embedding
  - cntk.layers.layers.GlobalAveragePooling
  - cntk.layers.layers.GlobalMaxPooling
  - cntk.layers.layers.Label
  - cntk.layers.layers.LayerNormalization
  - cntk.layers.layers.MaxPooling
  - cntk.layers.layers.MaxUnpooling
  fullName: cntk.layers.layers
  langs:
  - python
  module: cntk.layers.layers
  name: layers
  source:
    id: layers
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 0
  type: Namespace
  uid: cntk.layers.layers
- _type: function
  fullName: cntk.layers.layers.Activation
  langs:
  - python
  module: cntk.layers.layers
  name: Activation
  source:
    id: Activation
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 1058
  summary: Layer factory function to create an activation layer. Activation functions
    can be used directly in CNTK, so there is no difference between `y = relu(x)`
    and `y = Activation(relu)(x)`. This layer is useful if one wants to configure
    the activation function with `default_options`, or when its invocation should
    be named.
  syntax:
    content: Activation(activation=<cntk.default_options.default_override_or object
      at 0x2b8bf9c24208>, name="")
    example: '````


      >>> model = Dense(500) >> Activation(C.relu) >> Dense(10)

      >>> # is the same as

      >>> model = Dense(500) >> C.relu >> Dense(10)

      >>> # and also the same as

      >>> model = Dense(500, activation=C.relu) >> Dense(10)

      ````'
    parameters:
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c24208>
      description: function to apply at the end, e.g. *relu*
      id: activation
      type:
      - Function, defaults to identity
    - description: the name of the function instance in the network
      id: name
      type:
      - str, defaults to ''
    return:
      description: A function that accepts one argument and applies the operation
        to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.Activation
- _type: function
  fullName: cntk.layers.layers.AveragePooling
  langs:
  - python
  module: cntk.layers.layers
  name: AveragePooling
  source:
    id: AveragePooling
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 888
  summary: 'Layer factory function to create an average-pooling layer.

    Like `Convolution()`, `AveragePooling()` processes items arranged on an N-dimensional
    grid, such as an image. Typically, each item is a vector. For each item, average-pooling
    computes the element-wise mean over a window ("receptive field") of items surrounding
    the item''s position on the grid.

    The size (spatial extent) of the receptive field is given by `filter_shape`. E.g.
    for 2D pooling, `filter_shape` should be a tuple of two integers, such as *(5,5)*.'
  syntax:
    content: AveragePooling(filter_shape, strides=1, pad=<cntk.default_options.default_override_or
      object at 0x2b8bf9c24160>, name="")
    example: "````\n\n>>> f = AveragePooling((3,3), strides=2)  # reduce dimensionality\
      \ by 2, pooling over windows of 3x3\n>>> h = Input((32,240,320))  # e.g. 32-dim\
      \ feature map\n>>> hp = f(h)\n>>> hp.shape  # spatial dimension has been halved\
      \ due to stride, and lost one due to 3x3 window without padding\n    (32, 119,\
      \ 159)\n````\n\n````\n\n>>> f = AveragePooling((2,2), strides=2)\n>>> f.update_signature((1,4,4))\n\
      >>> im = np.array([[[3, 5, 2, 6], [4, 2, 8, 3], [1, 6, 4, 7], [7, 3, 5, 9]]])\
      \  # a 4x4 image (feature-map depth 1 for simplicity)\n>>> im\n    array([[[3,\
      \ 5, 2, 6],\n            [4, 2, 8, 3],\n            [1, 6, 4, 7],\n        \
      \    [7, 3, 5, 9]]])\n>>> f([[im]])  # due to strides=2, this computes the averages\
      \ of each 2x2 sub-block\n    array([[[[[ 3.5 ,  4.75],\n              [ 4.25,\
      \  6.25]]]]], dtype=float32)\n````"
    parameters:
    - description: shape (spatial extent) of the receptive field, *not* including
        the input feature-map depth. E.g. (3,3) for a 2D convolution.
      id: filter_shape
      type:
      - int or tuple of ints
    - defaultValue: ''
      description: stride (increment when sliding over the input). Use a *tuple* to
        specify a per-axis value.
      id: strides
      type:
      - int or tuple of ints, defaults to 1
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c24160>
      description: if *False*, then the pooling operation will be shifted over the
        "valid" area of input, that is, no value outside the area is used. If `pad=True`
        on the other hand, pooling will be applied to all input positions, and positions
        outside the valid region will be excluded from the averaging. Use a *tuple*
        to specify a per-axis value.
      id: pad
      type:
      - bool or tuple of bools, defaults to False
    - defaultValue: '1'
      description: the name of the function instance in the network
      id: name
      type:
      - str, defaults to ''
    return:
      description: A function that accepts one argument and applies the average-pooling
        operation to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.AveragePooling
- _type: function
  fullName: cntk.layers.layers.BatchNormalization
  langs:
  - python
  module: cntk.layers.layers
  name: BatchNormalization
  source:
    id: BatchNormalization
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 1091
  summary: 'Layer factory function to create a batch-normalization layer.

    Batch normalization applies this formula to every input element (element-wise):
    `y = (x - batch_mean) / (batch_stddev + epsilon) * scale + bias` where `batch_mean`
    and `batch_stddev` are estimated on the minibatch and `scale` and `bias` are learned
    parameters. TODO: add paper reference

    During operation, this layer also estimates an aggregate running mean and standard
    deviation for use in inference.

    A `BatchNormalization` layer instance owns its learnable parameter tensors and
    exposes them as attributes `.scale` and `.bias`. The aggregate estimates are exposed
    as attributes `aggregate_mean`, `aggregate_variance`, and `aggregate_count`.'
  syntax:
    content: BatchNormalization(map_rank=<cntk.default_options.default_override_or
      object at 0x2b8bf9c24240>, init_scale=1, normalization_time_constant=<cntk.default_options.default_override_or
      object at 0x2b8bf9c24278>, blend_time_constant=0, epsilon=<cntk.default_options.default_override_or
      object at 0x2b8bf9c242b0>, use_cntk_engine=<cntk.default_options.default_override_or
      object at 0x2b8bf9c242e8>, name="")
    example: "````\n\n>>> # BatchNorm on an image with spatial pooling\n>>> f = BatchNormalization(map_rank=1)\n\
      >>> f.update_signature((3,480,640))\n>>> f.bias.shape, f.scale.shape  # due\
      \ to spatial pooling (map_rank=1), there are only 3 biases and scales, shared\
      \ across all pixel positions\n    ((3,), (3,))\n````"
    parameters:
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c242e8>
      id: map_rank
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c242b0>
      description: passing 1 means spatially-pooled batch-normalization, where normalization
        values will be tied across all pixel positions; while `None` will normalize
        all elements of the input tensor independently
      id: map_rank
      type:
      - 1 or None
    - defaultValue: '0'
      description: initial value for the `scale` parameter
      id: init_scale
      type:
      - float, default 1
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c24278>
      description: time constant for smoothing the batch statistics in order to compute
        aggregate estimates for inference.
      id: normalization_time_constant
      type:
      - int, default 5000
    - defaultValue: '1'
      description: epsilon added to the variance to avoid division by 0
      id: epsilon
      type:
      - float, default 0.00001
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c24240>
      description: if `True` then use CNTK's own engine instead of NVidia's.
      id: use_cntk_engine
      type:
      - bool, default False
    - description: the name of the function instance in the network
      id: name
      type:
      - str, optional
    return:
      description: A function that accepts one argument and applies the operation
        to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.BatchNormalization
- _type: function
  fullName: cntk.layers.layers.Convolution
  langs:
  - python
  module: cntk.layers.layers
  name: Convolution
  source:
    id: Convolution
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 251
  summary: 'Layer factory function to create a convolution layer.

    This implements a convolution operation over items arranged on an N-dimensional
    grid, such as pixels in an image. Typically, each item is a vector (e.g. pixel:
    R,G,B), and the result is, in turn, a vector. The item-grid dimensions are referred
    to as the *spatial* dimensions (e.g. dimensions of an image), while the vector
    dimension of the individual items is often called *feature-map depth*.

    For each item, convolution gathers a window ("receptive field") of items surrounding
    the item''s position on the grid, and applies a little fully-connected network
    to it (the same little network is applied to all item positions). The size (spatial
    extent) of the receptive field is given by `filter_shape`. E.g. to specify a 2D
    convolution, `filter_shape` should be a tuple of two integers, such as *(5,5)*;
    an example for a 3D convolution (e.g. video or an MRI scan) would be `filter_shape=(3,3,3)`;
    while for a 1D convolution (e.g. audio or text), `filter_shape` has one element,
    such as (3,) or just 3.

    The dimension of the input items (input feature-map depth) is not to be specified.
    It is known from the input. The dimension of the output items (output feature-map
    depth) generated for each item position is given by `num_filters`.

    If the input is a sequence, the sequence elements are by default treated independently.
    To convolve along the sequence dimension as well, pass `sequential=True`. This
    is useful for variable-length inputs, such as video or natural-language processing
    (word n-grams). Note, however, that convolution does not support sparse inputs.

    Both input and output items can be scalars intead of vectors. For scalar-valued
    input items, such as pixels on a black-and-white image, or samples of an audio
    clip, specify `reduction_rank=0`. If the output items are scalar, pass `num_filters=()`
    or `None`.

    A `Convolution` instance owns its weight parameter tensors *W* and *b*, and exposes
    them as an attributes `.W` and `.b`. The weights will have the shape `(num_filters,
    input_feature_map_depth, *filter_shape)`'
  syntax:
    content: Convolution(filter_shape, num_filters=None, sequential=False, activation=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1e668>, init=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1e6d8>, pad=<cntk.default_options.default_override_or object at
      0x2b8bf9c1e710>, strides=1, sharing=True, bias=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1e748>, init_bias=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1e780>, reduction_rank=1, transpose_weight=False, max_temp_mem_size_in_samples=0,
      op_name="Convolution", name="")
    example: "````\n\n>>> # 2D convolution of 5x4 receptive field with output feature-map\
      \ depth 128:\n>>> f = Convolution((5,4), 128, activation=C.relu)\n>>> x = Input((3,480,640))\
      \  # 3-channel color image\n>>> h = f(x)\n>>> h.shape\n    (128, 476, 637)\n\
      >>> f.W.shape  # will have the form (num_filters, input_depth, *filter_shape)\n\
      \    (128, 3, 5, 4)\n````\n\n````\n\n>>> # 2D convolution over a one-channel\
      \ black-and-white image, padding, and stride 2 along width dimension\n>>> f\
      \ = Convolution((3,3), 128, reduction_rank=0, pad=True, strides=(1,2), activation=C.relu)\n\
      >>> x = Input((480,640))\n>>> h = f(x)\n>>> h.shape\n    (128, 480, 319)\n>>>\
      \ f.W.shape\n    (128, 1, 3, 3)\n````\n\n````\n\n>>> # 3D convolution along\
      \ dynamic axis over a sequence of 2D color images\n>>> from cntk.layers.typing\
      \ import Sequence, Tensor\n>>> f = Convolution((2,5,4), 128, sequential=True,\
      \ activation=C.relu) # over 2 consecutive frames\n>>> x = Input(**Sequence[Tensor[3,480,640]])\
      \  # a variable-length video of 640x480 RGB images\n>>> h = f(x)\n>>> h.shape\
      \   # this is the shape per video frame: 637x476 activation vectors of length\
      \ 128 each\n    (128, 476, 637)\n>>> f.W.shape # (output featuer map depth,\
      \ input depth, and the three filter dimensions)\n    (128, 3, 2, 5, 4)\n````"
    parameters:
    - id: filter_shape
    - defaultValue: ''
      description: shape (spatial extent) of the receptive field, *not* including
        the input feature-map depth. E.g. (3,3) for a 2D convolution.
      id: filter_shape
      type:
      - int or tuple of ints
    - defaultValue: Convolution
      description: number of filters (output feature-map depth), or `()` to denote
        scalar output items (output shape will have no depth axis).
      id: num_filters
      type:
      - int, defaults to None
    - defaultValue: '0'
      description: if *True*, also convolve along the dynamic axis. `filter_shape[0]`
        corresponds to dynamic axis.
      id: sequential
      type:
      - bool, defaults to False
    - defaultValue: 'False'
      description: optional function to apply at the end, e.g. *relu*
      id: activation
      type:
      - Function, defaults to identity
    - defaultValue: '1'
      description: initial value of weights *W*
      id: init
      type:
      - scalar or NumPy array or cntk.initializer, defaults to glorot_uniform
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e780>
      description: if *False*, then the filter will be shifted over the "valid" area
        of input, that is, no value outside the area is used. If `pad=True` on the
        other hand, the filter will be applied to all input positions, and positions
        outside the valid region will be considered containing zero. Use a *tuple*
        to specify a per-axis value.
      id: pad
      type:
      - bool or tuple of bools, defaults to False
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e748>
      description: stride of the convolution (increment when sliding the filter over
        the input). Use a *tuple* to specify a per-axis value.
      id: strides
      type:
      - int or tuple of ints, defaults to 1
    - defaultValue: 'True'
      description: When *True*, every position uses the same Convolution kernel.  When
        *False*, you can have a different Convolution kernel per position, but *False*
        is not supported.
      id: sharing
      type:
      - bool, defaults to True
    - defaultValue: '1'
      description: the layer will have no bias if *False* is passed here
      id: bias
      type:
      - bool, optional, defaults to True
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e710>
      description: initial value of weights *b*
      id: init_bias
      type:
      - scalar or NumPy array or cntk.initializer, defaults to 0
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e6d8>
      description: set to 0 if input items are scalars (input has no depth axis),
        e.g. an audio signal or a black-and-white image that is stored with tensor
        shape (H,W) instead of (1,H,W)
      id: reduction_rank
      type:
      - int, defaults to 1
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e668>
      description: When this is *True* this is deconvolution
      id: transpose
      type:
      - bool, defaults to False
    - defaultValue: 'False'
      description: Limits the amount of memory for intermiadate convolution results.  A
        value of 0 means, memory is automatically managed.
      id: max_temp_mem_size_in_samples
      type:
      - int, defaults to 0
    - defaultValue: None
      description: the name of the function instance in the network
      id: name
      type:
      - str, defaults to ''
    return:
      description: A function that accepts one argument and applies the convolution
        operation to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.Convolution
- _type: function
  fullName: cntk.layers.layers.Convolution1D
  langs:
  - python
  module: cntk.layers.layers
  name: Convolution1D
  source:
    id: Convolution1D
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 454
  summary: Layer factory function to create a 1D convolution layer with optional non-linearity.
    Same as *Convolution()* except that filter_shape is verified to be 1-dimensional.
    See *Convolution()* for extensive documentation.
  syntax:
    content: Convolution1D(filter_shape, num_filters=None, activation=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1e7b8>, init=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1e828>, pad=<cntk.default_options.default_override_or object at
      0x2b8bf9c1e860>, strides=1, bias=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1e898>, init_bias=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1e8d0>, reduction_rank=1, name="")
    parameters:
    - description: shape (spatial extent) of the receptive field, *not* including
        the input feature-map depth. E.g. (3,3) for a 2D convolution.
      id: filter_shape
      type:
      - int or tuple of ints
    - defaultValue: ''
      description: number of filters (output feature-map depth), or `()` to denote
        scalar output items (output shape will have no depth axis).
      id: num_filters
      type:
      - int, defaults to None
    - defaultValue: '1'
      description: optional function to apply at the end, e.g. *relu*
      id: activation
      type:
      - Function, defaults to identity
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e8d0>
      description: initial value of weights *W*
      id: init
      type:
      - scalar or NumPy array or cntk.initializer, defaults to glorot_uniform
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e898>
      description: if *False*, then the filter will be shifted over the "valid" area
        of input, that is, no value outside the area is used. If `pad=True` on the
        other hand, the filter will be applied to all input positions, and positions
        outside the valid region will be considered containing zero. Use a *tuple*
        to specify a per-axis value.
      id: pad
      type:
      - bool or tuple of bools, defaults to False
    - defaultValue: '1'
      description: stride of the convolution (increment when sliding the filter over
        the input). Use a *tuple* to specify a per-axis value.
      id: strides
      type:
      - int or tuple of ints, defaults to 1
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e860>
      description: the layer will have no bias if *False* is passed here
      id: bias
      type:
      - bool, defaults to True
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e828>
      description: initial value of weights *b*
      id: init_bias
      type:
      - scalar or NumPy array or cntk.initializer, defaults to 0
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e7b8>
      description: set to 0 if input items are scalars (input has no depth axis),
        e.g. an audio signal or a black-and-white image that is stored with tensor
        shape (H,W) instead of (1,H,W)
      id: reduction_rank
      type:
      - int, defaults to 1
    - defaultValue: None
      description: the name of the function instance in the network
      id: name
      type:
      - str, defaults to ''
    return:
      description: A function that accepts one argument and applies the convolution
        operation to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.Convolution1D
- _type: function
  fullName: cntk.layers.layers.Convolution2D
  langs:
  - python
  module: cntk.layers.layers
  name: Convolution2D
  source:
    id: Convolution2D
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 503
  summary: Layer factory function to create a 2D convolution layer with optional non-linearity.
    Same as *Convolution()* except that filter_shape is verified to be 2-dimensional.
    See *Convolution()* for extensive documentation.
  syntax:
    content: Convolution2D(filter_shape, num_filters=None, activation=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1e908>, init=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1e978>, pad=<cntk.default_options.default_override_or object at
      0x2b8bf9c1e9b0>, strides=1, bias=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1e9e8>, init_bias=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1ea20>, reduction_rank=1, name="")
    parameters:
    - description: shape (spatial extent) of the receptive field, *not* including
        the input feature-map depth. E.g. (3,3) for a 2D convolution.
      id: filter_shape
      type:
      - int or tuple of ints
    - defaultValue: ''
      description: number of filters (output feature-map depth), or `()` to denote
        scalar output items (output shape will have no depth axis).
      id: num_filters
      type:
      - int, defaults to None
    - defaultValue: '1'
      description: optional function to apply at the end, e.g. *relu*
      id: activation
      type:
      - Function, defaults to identity
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ea20>
      description: initial value of weights *W*
      id: init
      type:
      - scalar or NumPy array or cntk.initializer, defaults to glorot_uniform
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e9e8>
      description: if *False*, then the filter will be shifted over the "valid" area
        of input, that is, no value outside the area is used. If `pad=True` on the
        other hand, the filter will be applied to all input positions, and positions
        outside the valid region will be considered containing zero. Use a *tuple*
        to specify a per-axis value.
      id: pad
      type:
      - bool or tuple of bools, defaults to False
    - defaultValue: '1'
      description: stride of the convolution (increment when sliding the filter over
        the input). Use a *tuple* to specify a per-axis value.
      id: strides
      type:
      - int or tuple of ints, defaults to 1
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e9b0>
      description: the layer will have no bias if *False* is passed here
      id: bias
      type:
      - bool, defaults to True
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e978>
      description: initial value of weights *b*
      id: init_bias
      type:
      - scalar or NumPy array or cntk.initializer, defaults to 0
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e908>
      description: set to 0 if input items are scalars (input has no depth axis),
        e.g. an audio signal or a black-and-white image that is stored with tensor
        shape (H,W) instead of (1,H,W)
      id: reduction_rank
      type:
      - int, defaults to 1
    - defaultValue: None
      description: the name of the function instance in the network
      id: name
      type:
      - str, defaults to ''
    return:
      description: A function that accepts one argument and applies the convolution
        operation to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.Convolution2D
- _type: function
  fullName: cntk.layers.layers.Convolution3D
  langs:
  - python
  module: cntk.layers.layers
  name: Convolution3D
  source:
    id: Convolution3D
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 553
  summary: Layer factory function to create a 3D convolution layer with optional non-linearity.
    Same as *Convolution()* except that filter_shape is verified to be 3-dimensional.
    See *Convolution()* for extensive documentation.
  syntax:
    content: Convolution3D(filter_shape, num_filters=None, activation=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1ea58>, init=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1eac8>, pad=<cntk.default_options.default_override_or object at
      0x2b8bf9c1eb00>, strides=1, bias=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1eb38>, init_bias=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1eb70>, reduction_rank=1, name="")
    parameters:
    - description: shape (spatial extent) of the receptive field, *not* including
        the input feature-map depth. E.g. (3,3) for a 2D convolution.
      id: filter_shape
      type:
      - int or tuple of ints
    - defaultValue: ''
      description: number of filters (output feature-map depth), or `()` to denote
        scalar output items (output shape will have no depth axis).
      id: num_filters
      type:
      - int, defaults to None
    - defaultValue: '1'
      description: optional function to apply at the end, e.g. *relu*
      id: activation
      type:
      - Function, defaults to identity
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1eb70>
      description: initial value of weights *W*
      id: init
      type:
      - scalar or NumPy array or cntk.initializer, defaults to glorot_uniform
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1eb38>
      description: if *False*, then the filter will be shifted over the "valid" area
        of input, that is, no value outside the area is used. If `pad=True` on the
        other hand, the filter will be applied to all input positions, and positions
        outside the valid region will be considered containing zero. Use a *tuple*
        to specify a per-axis value.
      id: pad
      type:
      - bool or tuple of bools, defaults to False
    - defaultValue: '1'
      description: stride of the convolution (increment when sliding the filter over
        the input). Use a *tuple* to specify a per-axis value.
      id: strides
      type:
      - int or tuple of ints, defaults to 1
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1eb00>
      description: the layer will have no bias if *False* is passed here
      id: bias
      type:
      - bool, defaults to True
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1eac8>
      description: initial value of weights *b*
      id: init_bias
      type:
      - scalar or NumPy array or cntk.initializer, defaults to 0
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ea58>
      description: set to 0 if input items are scalars (input has no depth axis),
        e.g. an audio signal or a black-and-white image that is stored with tensor
        shape (H,W) instead of (1,H,W)
      id: reduction_rank
      type:
      - int, defaults to 1
    - defaultValue: None
      description: the name of the function instance in the network
      id: name
      type:
      - str, defaults to ''
    return:
      description: A function that accepts one argument and applies the convolution
        operation to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.Convolution3D
- _type: function
  fullName: cntk.layers.layers.ConvolutionTranspose
  langs:
  - python
  module: cntk.layers.layers
  name: ConvolutionTranspose
  source:
    id: ConvolutionTranspose
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 605
  summary: 'Layer factory function to create a convolution transpose layer.

    This implements a convolution_transpose operation over items arranged on an N-dimensional
    grid, such as pixels in an image. Typically, each item is a vector (e.g. pixel:
    R,G,B), and the result is, in turn, a vector. The item-grid dimensions are referred
    to as the *spatial* dimensions (e.g. dimensions of an image), while the vector
    dimensions of the individual items are often called *feature-map depth*.

    Convolution transpose is also known as `fractionally strided convolutional layers`,
    or, `deconvolution`. This operation is used in image and language processing applications.
    It supports arbitrary dimensions, strides, and padding.

    The forward and backward computation of convolution transpose is the inverse of
    convolution. That is, during forward pass the input layer''s items are spread
    into the output same as the backward spread of gradients in convolution. The backward
    pass, on the other hand, performs a convolution same as the forward pass of convolution.

    The size (spatial extent) of the receptive field for convolution transpose is
    given by `filter_shape`. E.g. to specify a 2D convolution transpose, `filter_shape`
    should be a tuple of two integers, such as *(5,5)*; an example for a 3D convolution
    transpose (e.g. video or an MRI scan) would be `filter_shape=(3,3,3)`; while for
    a 1D convolution transpose (e.g. audio or text), `filter_shape` has one element,
    such as (3,).

    The dimension of the input items (feature-map depth) is not specified, but known
    from the input. The dimension of the output items generated for each item position
    is given by `num_filters`.

    A `ConvolutionTranspose` instance owns its weight parameter tensors *W* and *b*,
    and exposes them as an attributes `.W` and `.b`. The weights will have the shape
    `(input_feature_map_depth, num_filters, *filter_shape)`.'
  syntax:
    content: ConvolutionTranspose(filter_shape, num_filters, activation=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1eba8>, init=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1ec18>, pad=<cntk.default_options.default_override_or object at
      0x2b8bf9c1ec50>, strides=1, sharing=True, bias=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1ec88>, init_bias=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1ecc0>, output_shape=None, reduction_rank=1, max_temp_mem_size_in_samples=0,
      name="")
    example: "````\n\n>>> # 2D convolution transpose of 3x4 receptive field with output\
      \ feature-map depth 128:\n>>> f = ConvolutionTranspose((3,4), 128, activation=C.relu)\n\
      >>> x = Input((3,480,640))  # 3-channel color image\n>>> h = f(x)\n>>> h.shape\n\
      \    (128, 482, 643)\n>>> f.W.shape  # will have the form (input_depth, num_filters,\
      \ *filter_shape)\n    (3, 128, 3, 4)\n````"
    parameters:
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1eba8>
      description: shape (spatial extent) of the receptive field, *not* including
        the input feature-map depth. E.g. (3,3) for a 2D convolution.
      id: filter_shape
      type:
      - int or tuple of ints
    - description: number of filters (output feature-map depth), or `()` to denote
        scalar output items (output shape will have no depth axis).
      id: num_filters
      type:
      - int
    - description: optional function to apply at the end, e.g. *relu*
      id: activation
      type:
      - Function, optional
    - defaultValue: ''
      description: initial value of weights *W*
      id: init
      type:
      - scalar or NumPy array or cntk.initializer, default glorot_uniform()
    - defaultValue: '0'
      description: if *False*, then the filter will be shifted over the "valid" area
        of input, that is, no value outside the area is used. If `pad=True` on the
        other hand, the filter will be applied to all input positions, and positions
        outside the valid region will be considered containing zero. Use a *tuple*
        to specify a per-axis value.
      id: pad
      type:
      - bool or tuple of bools, default False
    - defaultValue: '1'
      description: stride of the convolution (increment when sliding the filter over
        the input). Use a *tuple* to specify a per-axis value.
      id: strides
      type:
      - int or tuple of ints, default 1
    - defaultValue: None
      description: weight sharing, must be True for now.
      id: sharing
      type:
      - bool, default True
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ecc0>
      description: the layer will have no bias if *False* is passed here
      id: bias
      type:
      - bool, optional, default True
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ec88>
      description: initial value of weights *b*
      id: init_bias
      type:
      - scalar or NumPy array or cntk.initializer
    - defaultValue: 'True'
      description: output shape. When strides > 2, the output shape is non-deterministic.
        User can specify the wanted output shape. Note the specified shape must satisify
        the condition that if a convolution is perform from the output with the same
        setting, the result must have same shape as the input.
      id: output_shape
      type:
      - int or tuple of ints
    - defaultValue: '1'
      description: must be 1 for now. that is stored with tensor shape (H,W) instead
        of (1,H,W)
      id: reduction_rank
      type:
      - int, default 1
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ec50>
      description: set to a positive number to define the maximum workspace memory
        for convolution.
      id: max_temp_mem_size_in_samples
      type:
      - int, default 0
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ec18>
      description: the name of the Function instance in the network
      id: name
      type:
      - str, optional
    return:
      description: '`Function` that accepts one argument and applies the convolution
        operation to it'
  type: Method
  uid: cntk.layers.layers.ConvolutionTranspose
- _type: function
  fullName: cntk.layers.layers.ConvolutionTranspose1D
  langs:
  - python
  module: cntk.layers.layers
  name: ConvolutionTranspose1D
  source:
    id: ConvolutionTranspose1D
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 731
  summary: Layer factory function to create a 1D convolution transpose layer with
    optional non-linearity. Same as *ConvolutionTranspose()* except that filter_shape
    is verified to be 1-dimensional. See *ConvolutionTranspose()* for extensive documentation.
  syntax:
    content: ConvolutionTranspose1D(filter_shape, num_filters, activation=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1ecf8>, init=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1ed68>, pad=<cntk.default_options.default_override_or object at
      0x2b8bf9c1eda0>, strides=1, bias=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1edd8>, init_bias=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1ee10>, output_shape=None, name="")
    parameters:
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ecf8>
      id: filter_shape
    - id: num_filters
    - id: activation
    - defaultValue: ''
      id: init
    - defaultValue: None
      id: pad
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ee10>
      id: strides
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1edd8>
      id: bias
    - defaultValue: '1'
      id: init_bias
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1eda0>
      id: output_shape
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ed68>
      id: name
  type: Method
  uid: cntk.layers.layers.ConvolutionTranspose1D
- _type: function
  fullName: cntk.layers.layers.ConvolutionTranspose2D
  langs:
  - python
  module: cntk.layers.layers
  name: ConvolutionTranspose2D
  source:
    id: ConvolutionTranspose2D
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 757
  summary: Layer factory function to create a 2D convolution transpose layer with
    optional non-linearity. Same as *ConvolutionTranspose()* except that filter_shape
    is verified to be 2-dimensional. See *ConvolutionTranspose()* for extensive documentation.
  syntax:
    content: ConvolutionTranspose2D(filter_shape, num_filters, activation=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1ee48>, init=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1eeb8>, pad=<cntk.default_options.default_override_or object at
      0x2b8bf9c1eef0>, strides=1, bias=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1ef28>, init_bias=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1ef60>, output_shape=None, name="")
    parameters:
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ee48>
      id: filter_shape
    - id: num_filters
    - id: activation
    - defaultValue: ''
      id: init
    - defaultValue: None
      id: pad
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ef60>
      id: strides
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ef28>
      id: bias
    - defaultValue: '1'
      id: init_bias
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1eef0>
      id: output_shape
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1eeb8>
      id: name
  type: Method
  uid: cntk.layers.layers.ConvolutionTranspose2D
- _type: function
  fullName: cntk.layers.layers.ConvolutionTranspose3D
  langs:
  - python
  module: cntk.layers.layers
  name: ConvolutionTranspose3D
  source:
    id: ConvolutionTranspose3D
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 784
  summary: Layer factory function to create a 3D convolution transpose layer with
    optional non-linearity. Same as *ConvolutionTranspose()* except that filter_shape
    is verified to be 3-dimensional. See *ConvolutionTranspose()* for extensive documentation.
  syntax:
    content: ConvolutionTranspose3D(filter_shape, num_filters, activation=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1ef98>, init=<cntk.default_options.default_override_or object
      at 0x2b8bf9c24048>, pad=<cntk.default_options.default_override_or object at
      0x2b8bf9c24080>, strides=1, bias=<cntk.default_options.default_override_or object
      at 0x2b8bf9c240b8>, init_bias=<cntk.default_options.default_override_or object
      at 0x2b8bf9c240f0>, output_shape=None, name="")
    parameters:
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1ef98>
      id: filter_shape
    - id: num_filters
    - id: activation
    - defaultValue: ''
      id: init
    - defaultValue: None
      id: pad
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c240f0>
      id: strides
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c240b8>
      id: bias
    - defaultValue: '1'
      id: init_bias
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c24080>
      id: output_shape
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c24048>
      id: name
  type: Method
  uid: cntk.layers.layers.ConvolutionTranspose3D
- _type: function
  fullName: cntk.layers.layers.Dense
  langs:
  - python
  module: cntk.layers.layers
  name: Dense
  source:
    id: Dense
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 23
  summary: 'Layer factory function to create an instance of a fully-connected linear
    layer of the form *activation(input @ W + b)* with weights *W* and bias *b*, and
    *activation* and *b* being optional. *shape* may describe a tensor as well.

    A `Dense` layer instance owns its parameter tensors *W* and *b*, and exposes them
    as attributes `.W` and `.b`.'
  syntax:
    content: Dense(shape, activation=<cntk.default_options.default_override_or object
      at 0x2b8bf9c1e4a8>, init=<cntk.default_options.default_override_or object at
      0x2b8bf9c1e518>, input_rank=None, map_rank=None, bias=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1e550>, init_bias=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1e588>, name="")
    example: "````\n\n>>> f = Dense(5, activation=C.relu)\n>>> x = Input(3)\n>>> h\
      \ = f(x)\n>>> h.shape\n    (5,)\n>>> f.W.shape\n    (3, 5)\n>>> f.b.value\n\
      \    array([ 0.,  0.,  0.,  0.,  0.], dtype=float32)\n````\n\n````\n\n>>> #\
      \ activation through default options\n>>> with default_options(activation=C.relu):\n\
      ...     f = Dense(500)\n````"
    parameters:
    - description: vector or tensor dimension of the output of this layer
      id: shape
      type:
      - int or tuple of ints
    - defaultValue: ''
      description: optional function to apply at the end, e.g. *relu*
      id: activation
      type:
      - Function, defaults to identity
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e588>
      description: initial value of weights *W*
      id: init
      type:
      - scalar or NumPy array or cntk.initializer, defaults to glorot_uniform
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e550>
      description: number of inferred axes to add to W (*map_rank* must not be given)
      id: input_rank
      type:
      - int, defaults to None
    - defaultValue: None
      description: expand W to leave exactly *map_rank* axes (*input_rank* must not
        be given)
      id: map_rank
      type:
      - int, defaults to None
    - defaultValue: None
      description: the layer will have no bias if *False* is passed here
      id: bias
      type:
      - bool, optional, defaults to True
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e518>
      description: initial value of weights *b*
      id: init_bias
      type:
      - scalar or NumPy array or cntk.initializer, defualts to 0
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e4a8>
      description: the name of the function instance in the network
      id: name
      type:
      - str, defaults to ''
    return:
      description: A function that accepts one argument and applies the operation
        to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.Dense
- _type: function
  fullName: cntk.layers.layers.Dropout
  langs:
  - python
  module: cntk.layers.layers
  name: Dropout
  source:
    id: Dropout
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 1020
  summary: 'Layer factory function to create a drop-out layer.

    The dropout rate can be specified as the probability of *dropping* a value (`dropout_rate`).
    E.g. `Dropout(0.3)` means "drop 30% o the activation values." Alternatively, it
    can also be specified as the probability of *keeping* a value (`keep_prob`).'
  syntax:
    content: Dropout(dropout_rate=None, keep_prob=None, name="")
    example: '````


      >>> f = Dropout(0.2)   # "drop 20% of activations"

      >>> h = Input(3)

      >>> hd = f(h)

      ````


      ````


      >>> f = Dropout(keep_prob=0.8)   # "keep 80%"

      >>> h = Input(3)

      >>> hd = f(h)

      ````'
    parameters:
    - defaultValue: None
      description: probability of dropping out an element, mutually exclusive with
        `keep_prob`
      id: dropout_rate
      type:
      - float
    - defaultValue: None
      description: probability of keeping an element, mutually exclusive with `dropout_rate`
      id: keep_prob
      type:
      - float
    - description: the name of the function instance in the network
      id: name
      type:
      - str, defaults to ''
    return:
      description: A function that accepts one argument and applies the operation
        to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.Dropout
- _type: function
  fullName: cntk.layers.layers.Embedding
  langs:
  - python
  module: cntk.layers.layers
  name: Embedding
  source:
    id: Embedding
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 115
  summary: "Embedding(shape=None, init=glorot_uniform(), weights=None, name=''):\n\
    Layer factory function to create a embedding layer.\nAn embedding is conceptually\
    \ a lookup table. For every input token (e.g. a word or any category label), the\
    \ corresponding entry in in the lookup table is returned.\nIn CNTK, discrete items\
    \ such as words are represented as one-hot vectors. The table lookup is realized\
    \ as a matrix product, with a matrix whose rows are the embedding vectors. Note\
    \ that multiplying a matrix from the left with a one-hot vector is the same as\
    \ copying out the row for which the input vector is 1. CNTK has special optimizations\
    \ to make this operation as efficient as an actual table lookup if the input is\
    \ sparse.\nThe lookup table in this layer is learnable, unless a user-specified\
    \ one is supplied through the `weights` parameter. For example, to use an existing\
    \ embedding table from a file in numpy format, use this:\n<!-- literal_block {\"\
    dupnames\": [], \"names\": [], \"ids\": [], \"classes\": [], \"backrefs\": [],\
    \ \"xml:space\": \"preserve\"} -->\n\n````\n\n   Embedding(weights=np.load('PATH.npy'))\n\
    \   ````\nTo initialize a learnable lookup table with a given numpy array that\
    \ is to be used as the initial value, pass that array to the `init` parameter\
    \ (not `weights`).\nAn `Embedding` instance owns its weight parameter tensor *E*,\
    \ and exposes it as an attribute `.E`."
  syntax:
    content: Embedding(shape=None, init=<cntk.default_options.default_override_or
      object at 0x2b8bf9c1e5f8>, weights=None, name="")
    example: "````\n\n>>> # learnable embedding\n>>> f = Embedding(5)\n>>> x = Input(3)\n\
      >>> e = f(x)\n>>> e.shape\n    (5,)\n>>> f.E.shape\n    (3, 5)\n````\n\n````\n\
      \n>>> # user-supplied embedding\n>>> f = Embedding(weights=[[.5, .3, .1, .4,\
      \ .2], [.7, .6, .3, .2, .9]])\n>>> f.E.value\n    array([[ 0.5,  0.3,  0.1,\
      \  0.4,  0.2],\n           [ 0.7,  0.6,  0.3,  0.2,  0.9]], dtype=float32)\n\
      >>> x = Input(2, is_sparse=True)\n>>> e = f(x)\n>>> e.shape\n    (5,)\n>>> e(C.one_hot([[1],\
      \ [0], [0], [1]], num_classes=2))\narray([[[ 0.7,  0.6,  0.3,  0.2,  0.9]],\n\
      <BLANKLINE>\n       [[ 0.5,  0.3,  0.1,  0.4,  0.2]],\n<BLANKLINE>\n       [[\
      \ 0.5,  0.3,  0.1,  0.4,  0.2]],\n<BLANKLINE>\n       [[ 0.7,  0.6,  0.3,  0.2,\
      \  0.9]]], dtype=float32)\n````"
    parameters:
    - defaultValue: None
      description: vector or tensor dimension of the output of this layer
      id: shape
      type:
      - int or tuple of ints
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c1e5f8>
      description: (learnable embedding only) initial value of weights *E*
      id: init
      type:
      - scalar or NumPy array or cntk.initializer, defaults to glorot_uniform
    - defaultValue: None
      description: (user-supplied embedding only) the lookup table. The matrix rows
        are the embedding vectors, `weights[i,:]` being the embedding that corresponds
        to input category *i*.
      id: weights
      type:
      - NumPy array, mutually exclusive with init, defuats to None
    - description: the name of the function instance in the network
      id: name
      type:
      - str, defaults to ''
    return:
      description: A function that accepts one argument and applies the embedding
        operation to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.Embedding
- _type: function
  fullName: cntk.layers.layers.GlobalAveragePooling
  langs:
  - python
  module: cntk.layers.layers
  name: GlobalAveragePooling
  source:
    id: GlobalAveragePooling
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 970
  summary: 'Layer factory function to create a global average-pooling layer.

    The global average-pooling operation computes the element-wise mean over all items
    on an N-dimensional grid, such as an image.

    This operation is the same as applying `reduce_mean()` to all grid dimensions.'
  syntax:
    content: GlobalAveragePooling(name="")
    example: "````\n\n>>> f = GlobalAveragePooling()\n>>> f.update_signature((1,4,4))\n\
      >>> im = np.array([[[3, 5, 2, 6], [4, 2, 8, 3], [1, 6, 4, 7], [7, 3, 5, 9]]])\
      \  # a 4x4 image (feature-map depth 1 for simplicity)\n>>> im\n    array([[[3,\
      \ 5, 2, 6],\n            [4, 2, 8, 3],\n            [1, 6, 4, 7],\n        \
      \    [7, 3, 5, 9]]])\n>>> f([[im]])\n    array([[[[[ 4.6875]]]]], dtype=float32)\n\
      ````"
    parameters:
    - description: the name of the function instance in the network
      id: name
      type:
      - str, defaults to ''
    return:
      description: A function that accepts one argument and applies the operation
        to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.GlobalAveragePooling
- _type: function
  fullName: cntk.layers.layers.GlobalMaxPooling
  langs:
  - python
  module: cntk.layers.layers
  name: GlobalMaxPooling
  source:
    id: GlobalMaxPooling
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 940
  summary: 'Layer factory function to create a global max-pooling layer.

    The global max-pooling operation computes the element-wise maximum over all items
    on an N-dimensional grid, such as an image.

    This operation is the same as applying `reduce_max()` to all grid dimensions.'
  syntax:
    content: GlobalMaxPooling(name="")
    example: "````\n\n>>> f = GlobalMaxPooling()\n>>> f.update_signature((1,4,4))\n\
      >>> im = np.array([[[3, 5, 2, 6], [4, 2, 8, 3], [1, 6, 4, 7], [7, 3, 5, 9]]])\
      \  # a 4x4 image (feature-map depth 1 for simplicity)\n>>> im\n    array([[[3,\
      \ 5, 2, 6],\n            [4, 2, 8, 3],\n            [1, 6, 4, 7],\n        \
      \    [7, 3, 5, 9]]])\n>>> f([[im]])\n    array([[[[[ 9.]]]]], dtype=float32)\n\
      ````"
    parameters:
    - description: the name of the function instance in the network
      id: name
      type:
      - str, defaults to ''
    return:
      description: A function that accepts one argument and applies the operation
        to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.GlobalMaxPooling
- _type: function
  fullName: cntk.layers.layers.Label
  langs:
  - python
  module: cntk.layers.layers
  name: Label
  source:
    id: Label
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 1202
  summary: Layer factory function to create a dummy layer with a given name. This
    can be used to access an intermediate value flowing through computation.
  syntax:
    content: Label(name)
    example: "````\n\n>>> model = Dense(500) >> Label('hidden') >> Dense(10)\n>>>\
      \ model.update_signature(10)\n>>> intermediate_val = model.hidden\n>>> intermediate_val.shape\n\
      \    (500,)\n````"
    parameters:
    - id: name
    return:
      description: A function that accepts one argument and returns it with the desired
        name attached
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.Label
- _type: function
  fullName: cntk.layers.layers.LayerNormalization
  langs:
  - python
  module: cntk.layers.layers
  name: LayerNormalization
  source:
    id: LayerNormalization
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 1156
  summary: 'Layer factory function to create a function that implements layer normalization.

    Layer normalization applies this formula to every input element (element-wise):
    `y = (x - mean(x)) / (stddev(x) + epsilon) * scale + bias` where `scale` and `bias`
    are learned scalar parameters. TODO: add paper reference'
  syntax:
    content: LayerNormalization(initial_scale=1, initial_bias=0, epsilon=<cntk.default_options.default_override_or
      object at 0x2b8bf9c24320>, name="")
    example: "````\n\n>>> f = LayerNormalization(initial_scale=2, initial_bias=1)\n\
      >>> f.update_signature(4)\n>>> f([np.array([[4,0,0,4]])])  # result has mean\
      \ 1 and standard deviation 2, reflecting the initial values for scale and bias\n\
      \    array([[[ 2.99999, -0.99999, -0.99999,  2.99999]]], dtype=float32)\n````"
    parameters:
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c24320>
      description: initial value for the `scale` parameter
      id: initial_scale
      type:
      - float, default 1
    - defaultValue: '0'
      description: initial value for the `bias` parameter
      id: initial_bias
      type:
      - float, default 0
    - defaultValue: '1'
      description: epsilon added to the standard deviation to avoid division by 0
      id: epsilon
      type:
      - float, default 0.00001
    - description: the name of the Function instance in the network
      id: name
      type:
      - str, optional
    return:
      description: A function that accepts one argument and applies the operation
        to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.LayerNormalization
- _type: function
  fullName: cntk.layers.layers.MaxPooling
  langs:
  - python
  module: cntk.layers.layers
  name: MaxPooling
  source:
    id: MaxPooling
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 836
  summary: 'Layer factory function to create a max-pooling layer.

    Like `Convolution()`, `MaxPooling()` processes items arranged on an N-dimensional
    grid, such as an image. Typically, each item is a vector. For each item, max-pooling
    computes the element-wise maximum over a window ("receptive field") of items surrounding
    the item''s position on the grid.

    The size (spatial extent) of the receptive field is given by `filter_shape`. E.g.
    for 2D pooling, `filter_shape` should be a tuple of two integers, such as *(5,5)*.'
  syntax:
    content: MaxPooling(filter_shape, strides=1, pad=<cntk.default_options.default_override_or
      object at 0x2b8bf9c24128>, name="")
    example: "````\n\n>>> f = MaxPooling((3,3), strides=2)  # reduce dimensionality\
      \ by 2, pooling over windows of 3x3\n>>> h = Input((32,240,320))  # e.g. 32-dim\
      \ feature map\n>>> hp = f(h)\n>>> hp.shape  # spatial dimension has been halved\
      \ due to stride, and lost one due to 3x3 window without padding\n    (32, 119,\
      \ 159)\n````\n\n````\n\n>>> f = MaxPooling((2,2), strides=2)\n>>> f.update_signature((1,4,4))\n\
      >>> im = np.array([[[3, 5, 2, 6], [4, 2, 8, 3], [1, 6, 4, 7], [7, 3, 5, 9]]])\
      \  # a 4x4 image (feature-map depth 1 for simplicity)\n>>> im\n    array([[[3,\
      \ 5, 2, 6],\n            [4, 2, 8, 3],\n            [1, 6, 4, 7],\n        \
      \    [7, 3, 5, 9]]])\n>>> f([[im]])  # due to strides=2, this picks the max\
      \ out of each 2x2 sub-block\n    array([[[[[ 5.,  8.],\n              [ 7.,\
      \  9.]]]]], dtype=float32)\n````"
    parameters:
    - description: shape (spatial extent) of the receptive field, *not* including
        the input feature-map depth. E.g. (3,3) for a 2D convolution.
      id: filter_shape
      type:
      - int or tuple of ints
    - defaultValue: ''
      description: stride (increment when sliding over the input). Use a *tuple* to
        specify a per-axis value.
      id: strides
      type:
      - int or tuple of ints, defaults to 1
    - defaultValue: <cntk.default_options.default_override_or object at 0x2b8bf9c24128>
      description: if *False*, then the pooling operation will be shifted over the
        "valid" area of input, that is, no value outside the area is used. If `pad=True`
        on the other hand, pooling will be applied to all input positions, and positions
        outside the valid region will be considered containing zero. Use a *tuple*
        to specify a per-axis value.
      id: pad
      type:
      - bool or tuple of bools, defaults to False
    - defaultValue: '1'
      description: the name of the function instance in the network
      id: name
      type:
      - str, defaults to ''
    return:
      description: A function that accepts one argument and applies the max-pooling
        operation to it
      type:
      - cntk.ops.functions.Function
  type: Method
  uid: cntk.layers.layers.MaxPooling
- _type: function
  fullName: cntk.layers.layers.MaxUnpooling
  langs:
  - python
  module: cntk.layers.layers
  name: MaxUnpooling
  source:
    id: MaxUnpooling
    path: cntk/layers/layers.py
    remote:
      branch: master
      path: cntk/layers/layers.py
      repo: https://github.com/Microsoft/CNTK
    startLine: 1002
  syntax:
    content: MaxUnpooling(filter_shape, strides=1, pad=False, lower_pad=0, upper_pad=0,
      name="")
    parameters:
    - id: filter_shape
    - defaultValue: ''
      id: strides
    - defaultValue: '0'
      id: pad
    - defaultValue: '0'
      id: lower_pad
    - defaultValue: 'False'
      id: upper_pad
    - defaultValue: '1'
      id: name
  type: Method
  uid: cntk.layers.layers.MaxUnpooling
references:
- fullName: cntk.layers.layers.Activation
  isExternal: false
  name: Activation
  parent: cntk.layers.layers
  uid: cntk.layers.layers.Activation
- fullName: cntk.layers.layers.AveragePooling
  isExternal: false
  name: AveragePooling
  parent: cntk.layers.layers
  uid: cntk.layers.layers.AveragePooling
- fullName: cntk.layers.layers.BatchNormalization
  isExternal: false
  name: BatchNormalization
  parent: cntk.layers.layers
  uid: cntk.layers.layers.BatchNormalization
- fullName: cntk.layers.layers.Convolution
  isExternal: false
  name: Convolution
  parent: cntk.layers.layers
  uid: cntk.layers.layers.Convolution
- fullName: cntk.layers.layers.Convolution1D
  isExternal: false
  name: Convolution1D
  parent: cntk.layers.layers
  uid: cntk.layers.layers.Convolution1D
- fullName: cntk.layers.layers.Convolution2D
  isExternal: false
  name: Convolution2D
  parent: cntk.layers.layers
  uid: cntk.layers.layers.Convolution2D
- fullName: cntk.layers.layers.Convolution3D
  isExternal: false
  name: Convolution3D
  parent: cntk.layers.layers
  uid: cntk.layers.layers.Convolution3D
- fullName: cntk.layers.layers.ConvolutionTranspose
  isExternal: false
  name: ConvolutionTranspose
  parent: cntk.layers.layers
  uid: cntk.layers.layers.ConvolutionTranspose
- fullName: cntk.layers.layers.ConvolutionTranspose1D
  isExternal: false
  name: ConvolutionTranspose1D
  parent: cntk.layers.layers
  uid: cntk.layers.layers.ConvolutionTranspose1D
- fullName: cntk.layers.layers.ConvolutionTranspose2D
  isExternal: false
  name: ConvolutionTranspose2D
  parent: cntk.layers.layers
  uid: cntk.layers.layers.ConvolutionTranspose2D
- fullName: cntk.layers.layers.ConvolutionTranspose3D
  isExternal: false
  name: ConvolutionTranspose3D
  parent: cntk.layers.layers
  uid: cntk.layers.layers.ConvolutionTranspose3D
- fullName: cntk.layers.layers.Dense
  isExternal: false
  name: Dense
  parent: cntk.layers.layers
  uid: cntk.layers.layers.Dense
- fullName: cntk.layers.layers.Dropout
  isExternal: false
  name: Dropout
  parent: cntk.layers.layers
  uid: cntk.layers.layers.Dropout
- fullName: cntk.layers.layers.Embedding
  isExternal: false
  name: Embedding
  parent: cntk.layers.layers
  uid: cntk.layers.layers.Embedding
- fullName: cntk.layers.layers.GlobalAveragePooling
  isExternal: false
  name: GlobalAveragePooling
  parent: cntk.layers.layers
  uid: cntk.layers.layers.GlobalAveragePooling
- fullName: cntk.layers.layers.GlobalMaxPooling
  isExternal: false
  name: GlobalMaxPooling
  parent: cntk.layers.layers
  uid: cntk.layers.layers.GlobalMaxPooling
- fullName: cntk.layers.layers.Label
  isExternal: false
  name: Label
  parent: cntk.layers.layers
  uid: cntk.layers.layers.Label
- fullName: cntk.layers.layers.LayerNormalization
  isExternal: false
  name: LayerNormalization
  parent: cntk.layers.layers
  uid: cntk.layers.layers.LayerNormalization
- fullName: cntk.layers.layers.MaxPooling
  isExternal: false
  name: MaxPooling
  parent: cntk.layers.layers
  uid: cntk.layers.layers.MaxPooling
- fullName: cntk.layers.layers.MaxUnpooling
  isExternal: false
  name: MaxUnpooling
  parent: cntk.layers.layers
  uid: cntk.layers.layers.MaxUnpooling
